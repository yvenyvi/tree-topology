<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Tree Topology Network Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #333333;
            --node-color: #4293c7;
            --node-stroke: #2c5c82;
            --node-off-color: #a0a0a0;
            --node-off-stroke: #6e6e6e;
            --link-color: #999999;
            --link-off-color: #cccccc;
            --highlight-color: #ff7700;
            --panel-bg: #f0f0f0;
            --panel-border: #d0d0d0;
            --button-color: #2c5c82;
            --button-text: white;
            --tooltip-bg: rgba(255, 255, 255, 0.9);
            --tooltip-border: #aaaaaa;
            --message-color: #ff5500;
            --success-color: #44cc44;
            --error-color: #cc4444;
        }

        .dark-mode {
            --bg-color: #1a1a1a;
            --text-color: #f0f0f0;
            --node-color: #2d7bb5;
            --node-stroke: #76b0dc;
            --node-off-color: #505050;
            --node-off-stroke: #909090;
            --link-color: #767676;
            --link-off-color: #444444;
            --highlight-color: #ff9933;
            --panel-bg: #2a2a2a;
            --panel-border: #444444;
            --button-color: #4292c6;
            --button-text: white;
            --tooltip-bg: rgba(40, 40, 40, 0.95);
            --tooltip-border: #555555;
            --message-color: #ff7733;
            --success-color: #55dd55;
            --error-color: #dd5555;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        #app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #control-panel {
            padding: 12px;
            background-color: var(--panel-bg);
            border-bottom: 1px solid var(--panel-border);
        }

        #main-area {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        #tree-container {
            flex: 3;
            overflow: hidden;
            position: relative;
        }

        #stats-panel {
            flex: 1;
            min-width: 250px;
            max-width: 300px;
            background-color: var(--panel-bg);
            border-left: 1px solid var(--panel-border);
            padding: 12px;
            overflow-y: auto;
        }

        #stats-panel.hidden {
            display: none;
        }

        button {
            background-color: var(--button-color);
            color: var(--button-text);
            border: none;
            padding: 8px 12px;
            margin: 3px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            filter: brightness(1.1);
        }

        button:active {
            filter: brightness(0.9);
        }

        button:disabled {
            background-color: var(--node-off-color);
            cursor: not-allowed;
        }

        select {
            padding: 7px;
            border-radius: 4px;
            background-color: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--panel-border);
        }

        .node circle {
            cursor: pointer;
            stroke: var(--node-stroke);
            stroke-width: 2px;
            transition: fill 0.3s, stroke 0.3s, r 0.2s;
        }

        .node.off circle {
            fill: var(--node-off-color) !important;
            stroke: var(--node-off-stroke) !important;
        }

        .node text {
            font-size: 12px;
            fill: var(--text-color);
            pointer-events: none;
            transition: fill 0.3s;
        }

        .link {
            fill: none;
            stroke: var(--link-color);
            stroke-width: 1.5px;
            transition: stroke 0.3s, stroke-dasharray 0.3s;
        }

        .link.off {
            stroke: var(--link-off-color);
            stroke-dasharray: 4;
        }

        .link.highlight {
            stroke: var(--highlight-color);
            stroke-width: 3px;
        }

        .tooltip {
            position: absolute;
            padding: 8px;
            background-color: var(--tooltip-bg);
            border: 1px solid var(--tooltip-border);
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            max-width: 250px;
            z-index: 1000;
        }

        .message-packet {
            fill: var(--message-color);
            r: 5;
            filter: drop-shadow(0 0 3px var(--message-color));
        }

        .message-packet-glow {
            fill: var(--message-color);
            opacity: 0.5;
            r: 8;
            filter: blur(3px);
        }

        .message-packet-trail {
            fill: var(--message-color);
            opacity: 0.3;
        }

        .center-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--tooltip-bg);
            border: 1px solid var(--tooltip-border);
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            min-width: 250px;
        }

        .center-message.success {
            border-left: 5px solid var(--success-color);
        }

        .center-message.error {
            border-left: 5px solid var(--error-color);
        }

        .center-message-icon {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .dialog {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--panel-bg);
            border: 1px solid var(--panel-border);
            padding: 20px;
            border-radius: 8px;
            z-index: 1000;
            display: none;
        }

        .dialog input {
            width: 100%;
            padding: 8px;
            margin: 8px 0;
            border-radius: 4px;
            border: 1px solid var(--panel-border);
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        .dialog-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }

        .dialog-buttons button {
            width: 45%;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
            margin-left: 8px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--node-off-color);
            transition: .4s;
            border-radius: 20px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--highlight-color);
        }

        input:checked + .slider:before {
            transform: translateX(20px);
        }

        .node-control-row {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .context-menu {
            position: absolute;
            background-color: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 4px;
            padding: 5px 0;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            display: none;
        }

        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .context-menu-item:hover {
            background-color: var(--button-color);
            color: var(--button-text);
        }

        .simulation-controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
            border-top: 1px solid var(--panel-border);
            padding-top: 8px;
        }

        .panel-section {
            margin: 8px 0;
            border-bottom: 1px solid var(--panel-border);
            padding-bottom: 8px;
        }

        .panel-title {
            font-weight: bold;
            margin-bottom: 6px;
        }

        /* Animation for collapsing nodes */
        .node-exit {
            opacity: 0;
            transition: opacity 0.3s;
        }

        .node.receiving-message circle {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { r: 10; }
            50% { r: 13; }
            100% { r: 10; }
        }

        .simulation-legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: var(--tooltip-bg);
            border: 1px solid var(--tooltip-border);
            border-radius: 4px;
            padding: 10px;
            display: none;
            z-index: 100;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 8px;
            border-radius: 50%;
        }

        /* For smaller screens */
        @media (max-width: 768px) {
            #main-area {
                flex-direction: column;
            }
            
            #stats-panel {
                max-width: none;
                border-left: none;
                border-top: 1px solid var(--panel-border);
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="control-panel">
            <div class="panel-section">
                <button id="add-root-btn">Add Root Node</button>
                <button id="expand-all-btn" disabled>Expand All</button>
                <button id="collapse-all-btn" disabled>Collapse All</button>
                <button id="reset-tree-btn" disabled>Reset Tree</button>
                <button id="toggle-stats-btn">Toggle Statistics</button>
                <button id="toggle-dark-mode-btn">Toggle Dark Mode</button>
            </div>
            <div class="simulation-controls">
                <span>Simulation:</span>
                <select id="source-node-select" disabled>
                    <option value="">Select source node</option>
                </select>
                <select id="target-node-select" disabled>
                    <option value="">Select target node</option>
                </select>
                <button id="simulate-btn" disabled>Simulate Message</button>
                <button id="stop-simulation-btn" disabled>Stop Sending Message</button>
                <button id="export-btn" disabled>Export Tree</button>
                <button id="import-btn">Import Tree</button>
                <input type="file" id="import-file" accept=".json" style="display: none;">
            </div>
        </div>
        
        <div id="main-area">
            <div id="tree-container">
                <svg id="tree-svg" width="100%" height="100%">
                    <g id="zoom-layer"></g>
                </svg>
                <div id="tooltip" class="tooltip"></div>
                <div id="center-message" class="center-message"></div>
                <div id="simulation-legend" class="simulation-legend">
                    <h4>Message Simulation</h4>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: var(--message-color);"></div>
                        <span>Message Packet</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: var(--highlight-color);"></div>
                        <span>Active Path</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: var(--node-off-color);"></div>
                        <span>Inactive Node</span>
                    </div>
                </div>
                <div id="context-menu" class="context-menu">
                    <div class="context-menu-item" id="add-child-menu">Add Child Node</div>
                    <div class="context-menu-item" id="rename-node-menu">Rename Node</div>
                    <div class="context-menu-item" id="toggle-node-menu">Toggle ON/OFF</div>
                    <div class="context-menu-item" id="toggle-collapse-menu">Expand/Collapse</div>
                    <div class="context-menu-item" id="delete-node-menu">Delete Node</div>
                </div>
            </div>
            
            <div id="stats-panel">
                <h3>Tree Statistics</h3>
                <div id="tree-stats">
                    <p>No tree data available</p>
                </div>
                <div id="path-info" style="display: none;">
                    <h3>Path Information</h3>
                    <div id="path-stats"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="node-dialog" class="dialog">
        <h3 id="dialog-title">Add Node</h3>
        <div>
            <label for="node-name">Node Name:</label>
            <input type="text" id="node-name" placeholder="Enter node name">
        </div>
        <div class="node-control-row">
            <label for="node-state">Node State:</label>
            <label class="toggle-switch">
                <input type="checkbox" id="node-state" checked>
                <span class="slider"></span>
            </label>
            <span id="state-label" style="margin-left: 8px;">ON</span>
        </div>
        <div class="dialog-buttons">
            <button id="dialog-cancel">Cancel</button>
            <button id="dialog-confirm">Confirm</button>
        </div>
    </div>

    <script>
        // Initialize the tree topology network application
        document.addEventListener('DOMContentLoaded', function() {
            // ========================
            // Global Variables
            // ========================
            let treeData = null;
            let currentNode = null;
            let root = null;
            let selectedSource = null;
            let selectedTarget = null;
            let isSimulating = false;
            let isDarkMode = false;
            let simulationInterval = null;
            let simulationSpeed = 500; // ms per hop
            let simulationCycleCount = 0;
            let maxSimulationCycles = 3; // Default number of cycles to run
            let currentPacket = null;
            let stopSimulation = false;
            
            // DOM Elements
            const svgEl = document.getElementById('tree-svg');
            const zoomLayer = document.getElementById('zoom-layer');
            const tooltip = document.getElementById('tooltip');
            const centerMessage = document.getElementById('center-message');
            const contextMenu = document.getElementById('context-menu');
            const nodeDialog = document.getElementById('node-dialog');
            const statsPanel = document.getElementById('stats-panel');
            const pathInfo = document.getElementById('path-info');
            const importFileInput = document.getElementById('import-file');
            const simulationLegend = document.getElementById('simulation-legend');

            // Control Buttons
            const addRootBtn = document.getElementById('add-root-btn');
            const expandAllBtn = document.getElementById('expand-all-btn');
            const collapseAllBtn = document.getElementById('collapse-all-btn');
            const resetTreeBtn = document.getElementById('reset-tree-btn');
            const toggleStatsBtn = document.getElementById('toggle-stats-btn');
            const toggleDarkModeBtn = document.getElementById('toggle-dark-mode-btn');
            const simulateBtn = document.getElementById('simulate-btn');
            const stopSimulationBtn = document.getElementById('stop-simulation-btn');
            const exportBtn = document.getElementById('export-btn');
            const importBtn = document.getElementById('import-btn');
            const sourceNodeSelect = document.getElementById('source-node-select');
            const targetNodeSelect = document.getElementById('target-node-select');

            // Dialog Elements
            const dialogTitle = document.getElementById('dialog-title');
            const nodeNameInput = document.getElementById('node-name');
            const nodeStateInput = document.getElementById('node-state');
            const stateLabel = document.getElementById('state-label');
            const dialogCancelBtn = document.getElementById('dialog-cancel');
            const dialogConfirmBtn = document.getElementById('dialog-confirm');

            // Context Menu Items
            const addChildMenuItem = document.getElementById('add-child-menu');
            const renameNodeMenuItem = document.getElementById('rename-node-menu');
            const toggleNodeMenuItem = document.getElementById('toggle-node-menu');
            const toggleCollapseMenuItem = document.getElementById('toggle-collapse-menu');
            const deleteNodeMenuItem = document.getElementById('delete-node-menu');

            // ========================
            // D3 Setup
            // ========================
            // Set initial SVG dimensions
            const margin = {top: 50, right: 50, bottom: 50, left: 50};
            let width = svgEl.clientWidth;
            let height = svgEl.clientHeight;
            
            // Create the tree layout
            const treeLayout = d3.tree()
                .nodeSize([70, 90])
                .separation((a, b) => a.parent === b.parent ? 1.2 : 1.4);
                
            // Initialize zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 3])
                .on('zoom', (event) => {
                    zoomLayer.setAttribute('transform', event.transform);
                });
                
            d3.select(svgEl).call(zoom);

            // Initial center position for the tree
            function centerTree() {
                const initialTransform = d3.zoomIdentity
                    .translate(width / 2, margin.top)
                    .scale(0.8);
                d3.select(svgEl).call(zoom.transform, initialTransform);
            }

            // ========================
            // Tree Data Management
            // ========================
            // Initialize or reset tree data
            function initTreeData() {
                return {
                    id: generateId(),
                    name: "Root",
                    children: [],
                    isOn: true,
                    _expanded: true
                };
            }

            // Generate a unique ID for nodes
            function generateId() {
                return 'node_' + Math.random().toString(36).substr(2, 9);
            }

            // Add a child node to the selected node
            function addChildNode(parentNode, nodeName, isOn = true) {
                const newNode = {
                    id: generateId(),
                    name: nodeName || `Node ${parentNode.children.length + 1}`,
                    children: [],
                    isOn: isOn,
                    _expanded: true
                };
                
                if (!parentNode.children) {
                    parentNode.children = [];
                }
                
                parentNode.children.push(newNode);
                updateTree();
                updateNodeSelects();
                return newNode;
            }

            // Delete a node and its subtree
            function deleteNode(nodeToDelete) {
                // Cannot delete the root
                if (!nodeToDelete.parent) {
                    showCenterMessage("Cannot delete the root node", "error");
                    return;
                }
                
                const parent = nodeToDelete.parent;
                parent.data.children = parent.data.children.filter(child => 
                    child.id !== nodeToDelete.data.id
                );
                
                updateTree();
                updateNodeSelects();
                updateTreeStats();
            }

            // Toggle a node's ON/OFF state
            function toggleNodeState(node) {
                node.data.isOn = !node.data.isOn;
                
                // If this is the root node, update all child nodes to match root's state
                if (!node.parent && !node.data.isOn) {
                    // Root is turned OFF, turn off all children recursively
                    setSubtreeState(node, false);
                }
                
                updateTree();
                updateNodeSelects();
            }
            
            // Set the state of a node and all its descendants
            function setSubtreeState(node, isOn) {
                // Set the state of the current node
                node.data.isOn = isOn;
                
                // Recursively set the state of all children
                if (node.children) {
                    node.children.forEach(child => {
                        setSubtreeState(child, isOn);
                    });
                }
                
                // Also handle collapsed children (_children)
                if (node._children) {
                    node._children.forEach(child => {
                        setSubtreeState(child, isOn);
                    });
                }
            }

            // Toggle a node's expanded/collapsed state
            function toggleNodeExpansion(node) {
                node.data._expanded = !node.data._expanded;
                updateTree();
            }

            // Expand all nodes in the tree
            function expandAll(node) {
                node.data._expanded = true;
                if (node.children) {
                    node.children.forEach(expandAll);
                }
            }

            // Collapse all nodes in the tree except root
            function collapseAll(node) {
                if (node.depth > 0) {
                    node.data._expanded = false;
                }
                if (node.children) {
                    node.children.forEach(collapseAll);
                }
            }

            // Rename a node
            function renameNode(node, newName) {
                node.data.name = newName;
                updateTree();
                updateNodeSelects();
            }

            // Find a node by its ID in the tree
            function findNodeById(nodeId, currentNode = root) {
                if (currentNode.data.id === nodeId) {
                    return currentNode;
                }
                
                if (currentNode.children) {
                    for (const child of currentNode.children) {
                        const found = findNodeById(nodeId, child);
                        if (found) return found;
                    }
                }
                
                return null;
            }

            // Export tree data to JSON
            function exportTreeData() {
                if (!treeData) return;
                
                const dataStr = JSON.stringify(treeData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = 'tree-topology-network.json';
                link.click();
                
                URL.revokeObjectURL(url);
            }

            // Import tree data from JSON file
            function importTreeData(jsonData) {
                try {
                    treeData = JSON.parse(jsonData);
                    updateTree();
                    updateNodeSelects();
                    enableButtons();
                } catch (error) {
                    showCenterMessage("Error importing data: " + error.message, "error");
                }
            }

            // ========================
            // Tree Visualization
            // ========================
            // Update the tree visualization
            function updateTree() {
                if (!treeData) return;
                
                // Create hierarchy and apply the tree layout
                root = d3.hierarchy(treeData);
                
                // Process the tree data for visualization
                root.each(node => {
                    // Generate unique ID if not present
                    if (!node.data.id) {
                        node.data.id = generateId();
                    }
                    
                    // Ensure isOn property exists
                    if (typeof node.data.isOn !== 'boolean') {
                        node.data.isOn = true;
                    }
                    
                    // Ensure _expanded property exists
                    if (typeof node.data._expanded !== 'boolean') {
                        node.data._expanded = true;
                    }
                    
                    // Handle collapsed nodes for visualization
                    if (node.children && !node.data._expanded) {
                        node._children = node.children;
                        node.children = null;
                    } else if (node._children && node.data._expanded) {
                        node.children = node._children;
                        node._children = null;
                    }
                });
                
                // Apply the tree layout to the root
                treeLayout(root);
                
                // Clear previous contents
                d3.select(zoomLayer).selectAll('*').remove();
                
                // Draw links first (to ensure they're below nodes)
                const links = d3.select(zoomLayer)
                    .append('g')
                    .attr('class', 'links')
                    .selectAll('path')
                    .data(root.links())
                    .enter()
                    .append('path')
                    .attr('class', d => {
                        const sourceOn = d.source.data.isOn;
                        const targetOn = d.target.data.isOn;
                        return `link ${(!sourceOn || !targetOn) ? 'off' : ''}`;
                    })
                    .attr('d', d => {
                        // Create curved links (horizontal tree layout)
                        return `M${d.source.y},${d.source.x}
                                C${(d.source.y + d.target.y) / 2},${d.source.x}
                                 ${(d.source.y + d.target.y) / 2},${d.target.x}
                                 ${d.target.y},${d.target.x}`;
                    })
                    .attr('id', d => `link-${d.source.data.id}-${d.target.data.id}`);
                
                // Create node groups
                const nodes = d3.select(zoomLayer)
                    .append('g')
                    .attr('class', 'nodes')
                    .selectAll('g')
                    .data(root.descendants())
                    .enter()
                    .append('g')
                    .attr('class', d => `node ${d.data.isOn ? '' : 'off'}`)
                    .attr('id', d => `node-${d.data.id}`)
                    .attr('transform', d => `translate(${d.y},${d.x})`)
                    .attr('data-id', d => d.data.id);
                
                // Add circles to nodes
                nodes.append('circle')
                    .attr('r', 10)
                    .attr('fill', d => d.data.isOn ? 'var(--node-color)' : 'var(--node-off-color)')
                    .on('click', handleNodeClick)
                    .on('dblclick', handleNodeDblClick)
                    .on('contextmenu', handleContextMenu)
                    .on('mouseover', showTooltip)
                    .on('mouseout', hideTooltip);
                
                // Add expand/collapse indicator for non-leaf nodes
                nodes.each(function(d) {
                    const node = d3.select(this);
                    
                    // Add expand/collapse button for nodes with children
                    if (d.children || d._children) {
                        node.append('circle')
                            .attr('class', 'expander')
                            .attr('r', 6)
                            .attr('cx', 0)
                            .attr('cy', -20)
                            .attr('fill', 'var(--bg-color)')
                            .attr('stroke', 'var(--node-stroke)')
                            .attr('stroke-width', 1.5)
                            .attr('cursor', 'pointer')
                            .on('click', (event, d) => {
                                event.stopPropagation();
                                toggleNodeExpansion(d);
                            });
                            
                        node.append('text')
                            .attr('class', 'expander-symbol')
                            .attr('x', 0)
                            .attr('y', -16)
                            .attr('text-anchor', 'middle')
                            .attr('font-size', '12px')
                            .attr('pointer-events', 'none')
                            .text(d.data._expanded ? '-' : '+');
                    }
                });
                
                // Add node labels
                nodes.append('text')
                    .attr('dy', '0.35em')
                    .attr('x', 0)
                    .attr('y', 25)
                    .attr('text-anchor', 'middle')
                    .text(d => d.data.name || 'Unnamed')
                    .each(function(d) {
                        // If the text is too long, truncate it
                        const text = d3.select(this);
                        const maxWidth = 70;
                        
                        if (this.getComputedTextLength() > maxWidth) {
                            let textContent = text.text();
                            while (this.getComputedTextLength() > maxWidth && textContent.length > 0) {
                                textContent = textContent.slice(0, -1);
                                text.text(textContent + '...');
                            }
                        }
                    });
                
                // Add state indicator
                nodes.append('circle')
                    .attr('class', 'state-indicator')
                    .attr('r', 5)
                    .attr('cx', 15)
                    .attr('cy', -12)
                    .attr('fill', d => d.data.isOn ? '#44cc44' : '#cc4444')
                    .attr('stroke', 'var(--bg-color)')
                    .attr('stroke-width', 1)
                    .attr('cursor', 'pointer')
                    .on('click', (event, d) => {
                        event.stopPropagation();
                        toggleNodeState(d);
                    });
                
                // Update tree statistics
                updateTreeStats();
            }

            // ========================
            // Visualization Helpers
            // ========================
            // Handle window resize
            function handleResize() {
                width = svgEl.clientWidth;
                height = svgEl.clientHeight;
                
                // Update the center position
                centerTree();
            }

            // Toggle dark mode
            function toggleDarkMode() {
                isDarkMode = !isDarkMode;
                document.body.classList.toggle('dark-mode', isDarkMode);
            }

            // Show tooltip for node
            function showTooltip(event, d) {
                const nodeEl = event.currentTarget;
                const rect = nodeEl.getBoundingClientRect();
                const svgRect = svgEl.getBoundingClientRect();
                
                // Calculate position
                const x = rect.left + rect.width / 2 - svgRect.left;
                const y = rect.top - svgRect.top;
                
                // Prepare tooltip content
                const content = `
                    <div><strong>Name:</strong> ${d.data.name}</div>
                    <div><strong>ID:</strong> ${d.data.id}</div>
                    <div><strong>Depth:</strong> ${d.depth}</div>
                    <div><strong>Parent:</strong> ${d.parent ? d.parent.data.name : 'None'}</div>
                    <div><strong>Children:</strong> ${d.children ? d.children.length : 0}</div>
                    <div><strong>State:</strong> ${d.data.isOn ? 'ON' : 'OFF'}</div>
                    <div><em>Right-click for options</em></div>
                `;
                
                tooltip.innerHTML = content;
                tooltip.style.left = `${x}px`;
                tooltip.style.top = `${y - 10}px`;
                tooltip.style.opacity = 1;
            }

            // Hide tooltip
            function hideTooltip() {
                tooltip.style.opacity = 0;
            }

            // Show a center message
            function showCenterMessage(message, duration = 3000) {
                centerMessage.textContent = message;
                centerMessage.style.display = 'block';
                
                setTimeout(() => {
                    centerMessage.style.display = 'none';
                }, duration);
            }

            // Update tree statistics
            function updateTreeStats() {
                if (!root) {
                    document.getElementById('tree-stats').innerHTML = '<p>No tree data available</p>';
                    return;
                }
                
                // Calculate various tree statistics
                let totalNodes = 0;
                let maxDepth = 0;
                let nodesOn = 0;
                let nodesOff = 0;
                let reachableLeafNodes = 0;
                
                root.eachBefore(node => {
                    totalNodes++;
                    maxDepth = Math.max(maxDepth, node.depth);
                    
                    if (node.data.isOn) {
                        nodesOn++;
                    } else {
                        nodesOff++;
                    }
                    
                    // Check if it's a reachable leaf node
                    if (isNodeReachable(node) && !node.children && !node._children) {
                        reachableLeafNodes++;
                    }
                });
                
                // Find the longest path
                let longestPath = 0;
                let longestPathPair = null;
                
                // Check all possible paths between nodes
                const leaves = [];
                root.leaves().forEach(leaf => {
                    leaves.push(leaf);
                });
                
                for (let i = 0; i < leaves.length; i++) {
                    for (let j = i + 1; j < leaves.length; j++) {
                        const path = findPath(leaves[i], leaves[j]);
                        if (path && path.length > longestPath) {
                            longestPath = path.length;
                            longestPathPair = [leaves[i].data.name, leaves[j].data.name];
                        }
                    }
                }
                
                // Update the stats panel
                const statsHTML = `
                    <div><strong>Total Nodes:</strong> ${totalNodes}</div>
                    <div><strong>Maximum Depth:</strong> ${maxDepth}</div>
                    <div><strong>Nodes ON:</strong> ${nodesOn}</div>
                    <div><strong>Nodes OFF:</strong> ${nodesOff}</div>
                    <div><strong>Reachable Leaf Nodes:</strong> ${reachableLeafNodes}</div>
                    ${longestPathPair ? 
                        `<div><strong>Longest Path:</strong> ${longestPath - 1} hops<br/>${longestPathPair[0]} ↔ ${longestPathPair[1]}</div>` : 
                        '<div><strong>Longest Path:</strong> N/A</div>'}
                `;
                
                document.getElementById('tree-stats').innerHTML = statsHTML;
            }

            // Check if a node is reachable from root
            function isNodeReachable(node) {
                if (!root.data.isOn) return false;
                
                let current = node;
                let isReachable = true;
                
                // Check if all nodes in the path to the root are ON
                while (current && current !== root) {
                    if (!current.data.isOn) {
                        isReachable = false;
                        break;
                    }
                    current = current.parent;
                }
                
                return isReachable;
            }

            // Find path between two nodes
            function findPath(sourceNode, targetNode) {
                // Find lowest common ancestor
                const sourcePath = [];
                const targetPath = [];
                
                let current = sourceNode;
                while (current) {
                    sourcePath.unshift(current);
                    current = current.parent;
                }
                
                current = targetNode;
                while (current) {
                    targetPath.unshift(current);
                    current = current.parent;
                }
                
                // Find the lowest common ancestor
                let i = 0;
                while (i < sourcePath.length && i < targetPath.length && 
                       sourcePath[i] === targetPath[i]) {
                    i++;
                }
                
                // Build the full path
                const commonAncestor = i > 0 ? sourcePath[i - 1] : null;
                if (!commonAncestor) return null;
                
                const fullPath = [];
                
                // Add path from source to common ancestor (backwards)
                for (let j = sourcePath.length - 1; j >= i - 1; j--) {
                    fullPath.push(sourcePath[j]);
                }
                
                // Add path from common ancestor to target (forwards, skipping the common ancestor)
                for (let j = i; j < targetPath.length; j++) {
                    fullPath.push(targetPath[j]);
                }
                
                return fullPath;
            }

            // Update node select dropdowns
            function updateNodeSelects() {
                if (!root) return;
                
                // Clear existing options
                sourceNodeSelect.innerHTML = '<option value="">Select source node</option>';
                targetNodeSelect.innerHTML = '<option value="">Select target node</option>';
                
                // Add options for all nodes
                const addOptions = (node) => {
                    // Create option element
                    const sourceOption = document.createElement('option');
                    sourceOption.value = node.data.id;
                    sourceOption.textContent = node.data.name;
                    sourceOption.disabled = !node.data.isOn;
                    sourceNodeSelect.appendChild(sourceOption);
                    
                    const targetOption = document.createElement('option');
                    targetOption.value = node.data.id;
                    targetOption.textContent = node.data.name;
                    targetOption.disabled = !node.data.isOn;
                    targetNodeSelect.appendChild(targetOption);
                    
                    // Process children
                    if (node.children) {
                        node.children.forEach(addOptions);
                    }
                };
                
                // Start with the root
                addOptions(root);
                
                // Update selected values
                if (selectedSource) {
                    sourceNodeSelect.value = selectedSource;
                }
                if (selectedTarget) {
                    targetNodeSelect.value = selectedTarget;
                }
                
                // Enable/disable simulation button
                simulateBtn.disabled = !(sourceNodeSelect.value && targetNodeSelect.value && 
                                         sourceNodeSelect.value !== targetNodeSelect.value);
            }

            // ========================
            // User Interactions
            // ========================
            // Handle node click
            function handleNodeClick(event, d) {
                // Don't propagate the event to avoid unwanted behaviors
                event.stopPropagation();
                
                // If we're simulating, don't allow interactions
                if (isSimulating) return;
                
                // Store the current node for potential operations
                currentNode = d;
                
                // Toggle selection for simulation (first click = source, second = target)
                if (!selectedSource) {
                    selectedSource = d.data.id;
                    sourceNodeSelect.value = selectedSource;
                    d3.select(`#node-${d.data.id} circle`).attr('stroke', 'var(--highlight-color)').attr('stroke-width', 3);
                } else if (!selectedTarget) {
                    // Don't select the same node for source and target
                    if (d.data.id !== selectedSource) {
                        selectedTarget = d.data.id;
                        targetNodeSelect.value = selectedTarget;
                        d3.select(`#node-${d.data.id} circle`).attr('stroke', 'var(--highlight-color)').attr('stroke-width', 3);
                        
                        // Enable the simulate button
                        simulateBtn.disabled = false;
                    }
                } else {
                    // If both are already selected, reset and select this one as source
                    d3.selectAll('.node circle').attr('stroke', function() {
                        return d3.select(this.parentNode).classed('off') ? 
                            'var(--node-off-stroke)' : 'var(--node-stroke)';
                    }).attr('stroke-width', 2);
                    
                    selectedSource = d.data.id;
                    selectedTarget = null;
                    
                    sourceNodeSelect.value = selectedSource;
                    targetNodeSelect.value = '';
                    
                    d3.select(`#node-${d.data.id} circle`).attr('stroke', 'var(--highlight-color)').attr('stroke-width', 3);
                    
                    // Disable the simulate button
                    simulateBtn.disabled = true;
                }
            }

            // Handle node double click for renaming
            function handleNodeDblClick(event, d) {
                event.stopPropagation();
                
                // If we're simulating, don't allow interactions
                if (isSimulating) return;
                
                currentNode = d;
                showRenameDialog(d);
            }

            // Handle right-click for context menu
            function handleContextMenu(event, d) {
                event.preventDefault();
                event.stopPropagation();
                
                // If we're simulating, don't allow interactions
                if (isSimulating) return;
                
                currentNode = d;
                
                // Position context menu
                const rect = svgEl.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                contextMenu.style.left = `${x}px`;
                contextMenu.style.top = `${y}px`;
                contextMenu.style.display = 'block';
                
                // Update toggle text based on current states
                toggleNodeMenuItem.textContent = d.data.isOn ? 'Turn OFF' : 'Turn ON';
                toggleCollapseMenuItem.textContent = d.data._expanded ? 'Collapse Subtree' : 'Expand Subtree';
                
                // Disable delete option for root
                deleteNodeMenuItem.style.opacity = d.parent ? 1 : 0.5;
            }

            // ========================
            // Dialog Functions
            // ========================
            // Show dialog for adding a child node
            function showAddChildDialog(parentNode) {
                dialogTitle.textContent = 'Add Child Node';
                nodeNameInput.value = `Child ${parentNode.children ? parentNode.children.length + 1 : 1}`;
                nodeStateInput.checked = true;
                stateLabel.textContent = 'ON';
                
                nodeDialog.dataset.mode = 'add';
                nodeDialog.style.display = 'block';
                nodeNameInput.focus();
                nodeNameInput.select();
            }

            // Show dialog for renaming a node
            function showRenameDialog(node) {
                dialogTitle.textContent = 'Rename Node';
                nodeNameInput.value = node.data.name;
                nodeStateInput.checked = node.data.isOn;
                stateLabel.textContent = node.data.isOn ? 'ON' : 'OFF';
                
                nodeDialog.dataset.mode = 'rename';
                nodeDialog.style.display = 'block';
                nodeNameInput.focus();
                nodeNameInput.select();
            }

            // ========================
            // Simulation Functions
            // ========================
            // Simulate message routing between two nodes
            function simulateMessage() {
                if (!selectedSource || !selectedTarget || isSimulating) return;
                
                // Find the source and target nodes
                const sourceNode = findNodeById(selectedSource);
                const targetNode = findNodeById(selectedTarget);
                
                if (!sourceNode || !targetNode) {
                    showCenterMessage("Invalid source or target node");
                    return;
                }
                
                // Find the path between the nodes
                const path = findPath(sourceNode, targetNode);
                
                if (!path) {
                    showCenterMessage("Could not find a path between the selected nodes");
                    return;
                }
                
                // Check if all nodes in the path are ON
                let allNodesOn = true;
                let offNodeIndex = -1;
                
                for (let i = 0; i < path.length; i++) {
                    if (!path[i].data.isOn) {
                        allNodesOn = false;
                        offNodeIndex = i;
                        break;
                    }
                }
                
                // Reset any previous highlights
                d3.selectAll('.link').classed('highlight', false);
                
                // Highlight the path
                for (let i = 0; i < path.length - 1; i++) {
                    const linkId = `link-${path[i].data.id}-${path[i + 1].data.id}` || 
                                  `link-${path[i + 1].data.id}-${path[i].data.id}`;
                    d3.select(`#${linkId}`).classed('highlight', true);
                }
                
                // Display path information
                const hops = path.length - 1;
                const latencyPerHop = 50; // ms
                const totalLatency = hops * latencyPerHop;
                
                const pathStatsHTML = `
                    <div><strong>Source:</strong> ${sourceNode.data.name}</div>
                    <div><strong>Destination:</strong> ${targetNode.data.name}</div>
                    <div><strong>Number of Hops:</strong> ${hops}</div>
                    <div><strong>Total Latency:</strong> ${totalLatency}ms</div>
                    <div><strong>Status:</strong> ${allNodesOn ? 
                        '<span style="color: #4CAF50">✓ Path available</span>' : 
                        `<span style="color: #F44336">✗ Path interrupted at ${path[offNodeIndex].data.name} (OFF)</span>`}
                    </div>
                    <div><strong>Path:</strong> ${path.map(n => n.data.name).join(' → ')}</div>
                `;
                
                document.getElementById('path-stats').innerHTML = pathStatsHTML;
                pathInfo.style.display = 'block';
                
                // Animate the message packet along the path
                isSimulating = true;
                animateMessagePacket(path, allNodesOn, offNodeIndex);
            }

            // Animate a message packet along a path
            function animateMessagePacket(path, allNodesOn, offNodeIndex) {
                // Create a message packet (circle)
                const packet = d3.select(zoomLayer).append('circle')
                    .attr('class', 'message-packet')
                    .attr('r', 6);
                
                // Animation duration between each node
                const stepDuration = 500; // ms
                
                // Create animation keyframes
                let keyframes = [];
                
                for (let i = 0; i < path.length - 1; i++) {
                    // If we've reached an OFF node, stop animation
                    if (!allNodesOn && i >= offNodeIndex) break;
                    
                    const source = path[i];
                    const target = path[i + 1];
                    
                    keyframes.push({
                        position: [source.y, source.x],
                        duration: i === 0 ? 0 : stepDuration // First position is immediate
                    });
                    
                    keyframes.push({
                        position: [target.y, target.x],
                        duration: stepDuration
                    });
                }
                
                // If path is broken, add the final OFF node
                if (!allNodesOn) {
                    keyframes.push({
                        position: [path[offNodeIndex].y, path[offNodeIndex].x],
                        duration: stepDuration
                    });
                }
                
                // Function to animate through keyframes
                function animate(index) {
                    if (index >= keyframes.length) {
                        // Animation complete
                        setTimeout(() => {
                            packet.remove();
                            isSimulating = false;
                            
                            // Show completion message
                            showCenterMessage(allNodesOn ? 
                                "Message delivered successfully!" : 
                                `Message failed at ${path[offNodeIndex].data.name} (OFF)`,
                                2000);
                            
                            // Remove path highlights after a delay
                            setTimeout(() => {
                                d3.selectAll('.link').classed('highlight', false);
                            }, 3000);
                            
                        }, 500);
                        return;
                    }
                    
                    const frame = keyframes[index];
                    
                    packet.transition()
                        .duration(frame.duration)
                        .attr('cx', frame.position[0])
                        .attr('cy', frame.position[1])
                        .on('end', () => animate(index + 1));
                }
                
                // Start the animation
                animate(0);
            }

            // ========================
            // Event Listeners
            // ========================
            // Handle window resize
            window.addEventListener('resize', handleResize);
            
            // Close context menu on click elsewhere
            document.addEventListener('click', () => {
                contextMenu.style.display = 'none';
            });
            
            // Prevent default context menu
            svgEl.addEventListener('contextmenu', e => {
                e.preventDefault();
            });
            
            // Button click handlers
            addRootBtn.addEventListener('click', () => {
                if (!treeData) {
                    // Initialize tree data
                    treeData = initTreeData();
                    updateTree();
                    centerTree();
                    enableButtons();
                } else {
                    showCenterMessage("Root node already exists");
                }
            });
            
            expandAllBtn.addEventListener('click', () => {
                if (root) {
                    expandAll(root);
                    updateTree();
                }
            });
            
            collapseAllBtn.addEventListener('click', () => {
                if (root) {
                    collapseAll(root);
                    updateTree();
                }
            });
            
            resetTreeBtn.addEventListener('click', () => {
                // Confirm before resetting
                if (confirm("Are you sure you want to reset the tree? This will delete all nodes.")) {
                    treeData = null;
                    root = null;
                    selectedSource = null;
                    selectedTarget = null;
                    
                    // Clear the SVG
                    d3.select(zoomLayer).selectAll('*').remove();
                    
                    // Hide path info
                    pathInfo.style.display = 'none';
                    
                    // Update the statistics
                    updateTreeStats();
                    
                    // Clear dropdowns
                    sourceNodeSelect.innerHTML = '<option value="">Select source node</option>';
                    targetNodeSelect.innerHTML = '<option value="">Select target node</option>';
                    
                    // Disable buttons
                    disableButtons();
                }
            });
            
            toggleStatsBtn.addEventListener('click', () => {
                statsPanel.classList.toggle('hidden');
            });
            
            toggleDarkModeBtn.addEventListener('click', toggleDarkMode);
            
            simulateBtn.addEventListener('click', simulateMessage);
            
            exportBtn.addEventListener('click', exportTreeData);
            
            importBtn.addEventListener('click', () => {
                importFileInput.click();
            });
            
            // Context menu items
            addChildMenuItem.addEventListener('click', () => {
                if (currentNode) {
                    showAddChildDialog(currentNode);
                }
                contextMenu.style.display = 'none';
            });
            
            renameNodeMenuItem.addEventListener('click', () => {
                if (currentNode) {
                    showRenameDialog(currentNode);
                }
                contextMenu.style.display = 'none';
            });
            
            toggleNodeMenuItem.addEventListener('click', () => {
                if (currentNode) {
                    toggleNodeState(currentNode);
                }
                contextMenu.style.display = 'none';
            });
            
            toggleCollapseMenuItem.addEventListener('click', () => {
                if (currentNode) {
                    toggleNodeExpansion(currentNode);
                }
                contextMenu.style.display = 'none';
            });
            
            deleteNodeMenuItem.addEventListener('click', () => {
                if (currentNode && currentNode.parent) {
                    deleteNode(currentNode);
                } else if (currentNode) {
                    showCenterMessage("Cannot delete the root node");
                }
                contextMenu.style.display = 'none';
            });
            
            // Dialog event listeners
            nodeStateInput.addEventListener('change', () => {
                stateLabel.textContent = nodeStateInput.checked ? 'ON' : 'OFF';
            });
            
            dialogCancelBtn.addEventListener('click', () => {
                nodeDialog.style.display = 'none';
            });
            
            dialogConfirmBtn.addEventListener('click', () => {
                const mode = nodeDialog.dataset.mode;
                const nodeName = nodeNameInput.value.trim() || 'Unnamed';
                const isOn = nodeStateInput.checked;
                
                if (mode === 'add' && currentNode) {
                    addChildNode(currentNode.data, nodeName, isOn);
                } else if (mode === 'rename' && currentNode) {
                    renameNode(currentNode, nodeName);
                    currentNode.data.isOn = isOn;
                    updateTree();
                }
                
                nodeDialog.style.display = 'none';
            });
            
            // Select change handlers
            sourceNodeSelect.addEventListener('change', () => {
                // Reset highlights
                d3.selectAll('.node circle').attr('stroke', function() {
                    return d3.select(this.parentNode).classed('off') ? 
                        'var(--node-off-stroke)' : 'var(--node-stroke)';
                }).attr('stroke-width', 2);
                
                selectedSource = sourceNodeSelect.value || null;
                
                if (selectedSource) {
                    d3.select(`#node-${selectedSource} circle`).attr('stroke', 'var(--highlight-color)').attr('stroke-width', 3);
                }
                
                // Enable/disable simulate button
                simulateBtn.disabled = !(sourceNodeSelect.value && targetNodeSelect.value && 
                                       sourceNodeSelect.value !== targetNodeSelect.value);
            });
            
            targetNodeSelect.addEventListener('change', () => {
                // Reset highlights
                d3.selectAll('.node circle').attr('stroke', function() {
                    return d3.select(this.parentNode).classed('off') ? 
                        'var(--node-off-stroke)' : 'var(--node-stroke)';
                }).attr('stroke-width', 2);
                
                selectedTarget = targetNodeSelect.value || null;
                
                if (selectedSource) {
                    d3.select(`#node-${selectedSource} circle`).attr('stroke', 'var(--highlight-color)').attr('stroke-width', 3);
                }
                
                if (selectedTarget) {
                    d3.select(`#node-${selectedTarget} circle`).attr('stroke', 'var(--highlight-color)').attr('stroke-width', 3);
                }
                
                // Enable/disable simulate button
                simulateBtn.disabled = !(sourceNodeSelect.value && targetNodeSelect.value && 
                                       sourceNodeSelect.value !== targetNodeSelect.value);
            });
            
            // File input change handler
            importFileInput.addEventListener('change', () => {
                const file = importFileInput.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        importTreeData(e.target.result);
                    };
                    reader.readAsText(file);
                }
            });
            
            // ========================
            // Helper Functions
            // ========================
            // Enable all buttons when tree is initialized
            function enableButtons() {
                expandAllBtn.disabled = false;
                collapseAllBtn.disabled = false;
                resetTreeBtn.disabled = false;
                exportBtn.disabled = false;
            }
            
            // Disable buttons when no tree exists
            function disableButtons() {
                // Disable all tree-related buttons when no tree exists
                const buttonsToDisable = [
                    { element: expandAllBtn, label: 'Expand All' },
                    { element: collapseAllBtn, label: 'Collapse All' },
                    { element: resetTreeBtn, label: 'Reset Tree' },
                    { element: simulateBtn, label: 'Simulate Message' },
                    { element: exportBtn, label: 'Export Tree' }
                ];
                
                // Disable all buttons with visual feedback
                buttonsToDisable.forEach(btn => {
                    btn.element.disabled = true;
                    btn.element.title = `${btn.label} (Unavailable - No tree exists)`;
                    btn.element.classList.add('disabled-button');
                });
                
                // Disable node selection dropdowns
                sourceNodeSelect.disabled = true;
                sourceNodeSelect.title = "Source node selection unavailable - No tree exists";
                targetNodeSelect.disabled = true;
                targetNodeSelect.title = "Target node selection unavailable - No tree exists";
                
                // Show a helpful message in the center of the screen
                showCenterMessage("Create or import a tree to begin", 3000);
            }
            
            // ========================
            // Example Tree Generation
            // ========================
            // Generate a sample tree for demo purposes
            function generateSampleTree() {
                treeData = {
                    id: generateId(),
                    name: "Root",
                    isOn: true,
                    _expanded: true,
                    children: [
                        {
                            id: generateId(),
                            name: "Switch A",
                            isOn: true,
                            _expanded: true,
                            children: [
                                {
                                    id: generateId(),
                                    name: "Node A1",
                                    isOn: true,
                                    _expanded: true,
                                    children: []
                                },
                                {
                                    id: generateId(),
                                    name: "Node A2",
                                    isOn: false,
                                    _expanded: true,
                                    children: []
                                }
                            ]
                        },
                        {
                            id: generateId(),
                            name: "Switch B",
                            isOn: true,
                            _expanded: true,
                            children: [
                                {
                                    id: generateId(),
                                    name: "Node B1",
                                    isOn: true,
                                    _expanded: true,
                                    children: []
                                },
                                {
                                    id: generateId(),
                                    name: "Switch B2",
                                    isOn: true,
                                    _expanded: true,
                                    children: [
                                        {
                                            id: generateId(),
                                            name: "Node B2.1",
                                            isOn: true,
                                            _expanded: true,
                                            children: []
                                        },
                                        {
                                            id: generateId(),
                                            name: "Node B2.2",
                                            isOn: true,
                                            _expanded: true,
                                            children: []
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                };
                
                updateTree();
                centerTree();
                enableButtons();
                sourceNodeSelect.disabled = false;
                targetNodeSelect.disabled = false;
            }
            
            // Initialize with a sample tree
            generateSampleTree();
        });
    </script>
</body>
</html>